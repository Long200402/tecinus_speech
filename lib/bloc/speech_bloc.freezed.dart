// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'speech_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SpeechEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() nextQues,
    required TResult Function() preQues,
    required TResult Function() resetSpeech,
    required TResult Function(String? path, String? referenceText)
        sendFileToServer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? nextQues,
    TResult? Function()? preQues,
    TResult? Function()? resetSpeech,
    TResult? Function(String? path, String? referenceText)? sendFileToServer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? nextQues,
    TResult Function()? preQues,
    TResult Function()? resetSpeech,
    TResult Function(String? path, String? referenceText)? sendFileToServer,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(NextQues value) nextQues,
    required TResult Function(PreQues value) preQues,
    required TResult Function(ResetSpeech value) resetSpeech,
    required TResult Function(SendFileToServer value) sendFileToServer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(NextQues value)? nextQues,
    TResult? Function(PreQues value)? preQues,
    TResult? Function(ResetSpeech value)? resetSpeech,
    TResult? Function(SendFileToServer value)? sendFileToServer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(NextQues value)? nextQues,
    TResult Function(PreQues value)? preQues,
    TResult Function(ResetSpeech value)? resetSpeech,
    TResult Function(SendFileToServer value)? sendFileToServer,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpeechEventCopyWith<$Res> {
  factory $SpeechEventCopyWith(
          SpeechEvent value, $Res Function(SpeechEvent) then) =
      _$SpeechEventCopyWithImpl<$Res, SpeechEvent>;
}

/// @nodoc
class _$SpeechEventCopyWithImpl<$Res, $Val extends SpeechEvent>
    implements $SpeechEventCopyWith<$Res> {
  _$SpeechEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitImplCopyWith<$Res> {
  factory _$$InitImplCopyWith(
          _$InitImpl value, $Res Function(_$InitImpl) then) =
      __$$InitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res>
    extends _$SpeechEventCopyWithImpl<$Res, _$InitImpl>
    implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitImpl implements Init {
  const _$InitImpl();

  @override
  String toString() {
    return 'SpeechEvent.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() nextQues,
    required TResult Function() preQues,
    required TResult Function() resetSpeech,
    required TResult Function(String? path, String? referenceText)
        sendFileToServer,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? nextQues,
    TResult? Function()? preQues,
    TResult? Function()? resetSpeech,
    TResult? Function(String? path, String? referenceText)? sendFileToServer,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? nextQues,
    TResult Function()? preQues,
    TResult Function()? resetSpeech,
    TResult Function(String? path, String? referenceText)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(NextQues value) nextQues,
    required TResult Function(PreQues value) preQues,
    required TResult Function(ResetSpeech value) resetSpeech,
    required TResult Function(SendFileToServer value) sendFileToServer,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(NextQues value)? nextQues,
    TResult? Function(PreQues value)? preQues,
    TResult? Function(ResetSpeech value)? resetSpeech,
    TResult? Function(SendFileToServer value)? sendFileToServer,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(NextQues value)? nextQues,
    TResult Function(PreQues value)? preQues,
    TResult Function(ResetSpeech value)? resetSpeech,
    TResult Function(SendFileToServer value)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class Init implements SpeechEvent {
  const factory Init() = _$InitImpl;
}

/// @nodoc
abstract class _$$NextQuesImplCopyWith<$Res> {
  factory _$$NextQuesImplCopyWith(
          _$NextQuesImpl value, $Res Function(_$NextQuesImpl) then) =
      __$$NextQuesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NextQuesImplCopyWithImpl<$Res>
    extends _$SpeechEventCopyWithImpl<$Res, _$NextQuesImpl>
    implements _$$NextQuesImplCopyWith<$Res> {
  __$$NextQuesImplCopyWithImpl(
      _$NextQuesImpl _value, $Res Function(_$NextQuesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NextQuesImpl implements NextQues {
  const _$NextQuesImpl();

  @override
  String toString() {
    return 'SpeechEvent.nextQues()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NextQuesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() nextQues,
    required TResult Function() preQues,
    required TResult Function() resetSpeech,
    required TResult Function(String? path, String? referenceText)
        sendFileToServer,
  }) {
    return nextQues();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? nextQues,
    TResult? Function()? preQues,
    TResult? Function()? resetSpeech,
    TResult? Function(String? path, String? referenceText)? sendFileToServer,
  }) {
    return nextQues?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? nextQues,
    TResult Function()? preQues,
    TResult Function()? resetSpeech,
    TResult Function(String? path, String? referenceText)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (nextQues != null) {
      return nextQues();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(NextQues value) nextQues,
    required TResult Function(PreQues value) preQues,
    required TResult Function(ResetSpeech value) resetSpeech,
    required TResult Function(SendFileToServer value) sendFileToServer,
  }) {
    return nextQues(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(NextQues value)? nextQues,
    TResult? Function(PreQues value)? preQues,
    TResult? Function(ResetSpeech value)? resetSpeech,
    TResult? Function(SendFileToServer value)? sendFileToServer,
  }) {
    return nextQues?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(NextQues value)? nextQues,
    TResult Function(PreQues value)? preQues,
    TResult Function(ResetSpeech value)? resetSpeech,
    TResult Function(SendFileToServer value)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (nextQues != null) {
      return nextQues(this);
    }
    return orElse();
  }
}

abstract class NextQues implements SpeechEvent {
  const factory NextQues() = _$NextQuesImpl;
}

/// @nodoc
abstract class _$$PreQuesImplCopyWith<$Res> {
  factory _$$PreQuesImplCopyWith(
          _$PreQuesImpl value, $Res Function(_$PreQuesImpl) then) =
      __$$PreQuesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PreQuesImplCopyWithImpl<$Res>
    extends _$SpeechEventCopyWithImpl<$Res, _$PreQuesImpl>
    implements _$$PreQuesImplCopyWith<$Res> {
  __$$PreQuesImplCopyWithImpl(
      _$PreQuesImpl _value, $Res Function(_$PreQuesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PreQuesImpl implements PreQues {
  const _$PreQuesImpl();

  @override
  String toString() {
    return 'SpeechEvent.preQues()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PreQuesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() nextQues,
    required TResult Function() preQues,
    required TResult Function() resetSpeech,
    required TResult Function(String? path, String? referenceText)
        sendFileToServer,
  }) {
    return preQues();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? nextQues,
    TResult? Function()? preQues,
    TResult? Function()? resetSpeech,
    TResult? Function(String? path, String? referenceText)? sendFileToServer,
  }) {
    return preQues?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? nextQues,
    TResult Function()? preQues,
    TResult Function()? resetSpeech,
    TResult Function(String? path, String? referenceText)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (preQues != null) {
      return preQues();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(NextQues value) nextQues,
    required TResult Function(PreQues value) preQues,
    required TResult Function(ResetSpeech value) resetSpeech,
    required TResult Function(SendFileToServer value) sendFileToServer,
  }) {
    return preQues(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(NextQues value)? nextQues,
    TResult? Function(PreQues value)? preQues,
    TResult? Function(ResetSpeech value)? resetSpeech,
    TResult? Function(SendFileToServer value)? sendFileToServer,
  }) {
    return preQues?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(NextQues value)? nextQues,
    TResult Function(PreQues value)? preQues,
    TResult Function(ResetSpeech value)? resetSpeech,
    TResult Function(SendFileToServer value)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (preQues != null) {
      return preQues(this);
    }
    return orElse();
  }
}

abstract class PreQues implements SpeechEvent {
  const factory PreQues() = _$PreQuesImpl;
}

/// @nodoc
abstract class _$$ResetSpeechImplCopyWith<$Res> {
  factory _$$ResetSpeechImplCopyWith(
          _$ResetSpeechImpl value, $Res Function(_$ResetSpeechImpl) then) =
      __$$ResetSpeechImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ResetSpeechImplCopyWithImpl<$Res>
    extends _$SpeechEventCopyWithImpl<$Res, _$ResetSpeechImpl>
    implements _$$ResetSpeechImplCopyWith<$Res> {
  __$$ResetSpeechImplCopyWithImpl(
      _$ResetSpeechImpl _value, $Res Function(_$ResetSpeechImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ResetSpeechImpl implements ResetSpeech {
  const _$ResetSpeechImpl();

  @override
  String toString() {
    return 'SpeechEvent.resetSpeech()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ResetSpeechImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() nextQues,
    required TResult Function() preQues,
    required TResult Function() resetSpeech,
    required TResult Function(String? path, String? referenceText)
        sendFileToServer,
  }) {
    return resetSpeech();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? nextQues,
    TResult? Function()? preQues,
    TResult? Function()? resetSpeech,
    TResult? Function(String? path, String? referenceText)? sendFileToServer,
  }) {
    return resetSpeech?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? nextQues,
    TResult Function()? preQues,
    TResult Function()? resetSpeech,
    TResult Function(String? path, String? referenceText)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (resetSpeech != null) {
      return resetSpeech();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(NextQues value) nextQues,
    required TResult Function(PreQues value) preQues,
    required TResult Function(ResetSpeech value) resetSpeech,
    required TResult Function(SendFileToServer value) sendFileToServer,
  }) {
    return resetSpeech(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(NextQues value)? nextQues,
    TResult? Function(PreQues value)? preQues,
    TResult? Function(ResetSpeech value)? resetSpeech,
    TResult? Function(SendFileToServer value)? sendFileToServer,
  }) {
    return resetSpeech?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(NextQues value)? nextQues,
    TResult Function(PreQues value)? preQues,
    TResult Function(ResetSpeech value)? resetSpeech,
    TResult Function(SendFileToServer value)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (resetSpeech != null) {
      return resetSpeech(this);
    }
    return orElse();
  }
}

abstract class ResetSpeech implements SpeechEvent {
  const factory ResetSpeech() = _$ResetSpeechImpl;
}

/// @nodoc
abstract class _$$SendFileToServerImplCopyWith<$Res> {
  factory _$$SendFileToServerImplCopyWith(_$SendFileToServerImpl value,
          $Res Function(_$SendFileToServerImpl) then) =
      __$$SendFileToServerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? path, String? referenceText});
}

/// @nodoc
class __$$SendFileToServerImplCopyWithImpl<$Res>
    extends _$SpeechEventCopyWithImpl<$Res, _$SendFileToServerImpl>
    implements _$$SendFileToServerImplCopyWith<$Res> {
  __$$SendFileToServerImplCopyWithImpl(_$SendFileToServerImpl _value,
      $Res Function(_$SendFileToServerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = freezed,
    Object? referenceText = freezed,
  }) {
    return _then(_$SendFileToServerImpl(
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      referenceText: freezed == referenceText
          ? _value.referenceText
          : referenceText // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$SendFileToServerImpl implements SendFileToServer {
  const _$SendFileToServerImpl({this.path, this.referenceText});

  @override
  final String? path;
  @override
  final String? referenceText;

  @override
  String toString() {
    return 'SpeechEvent.sendFileToServer(path: $path, referenceText: $referenceText)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SendFileToServerImpl &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.referenceText, referenceText) ||
                other.referenceText == referenceText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path, referenceText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SendFileToServerImplCopyWith<_$SendFileToServerImpl> get copyWith =>
      __$$SendFileToServerImplCopyWithImpl<_$SendFileToServerImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() nextQues,
    required TResult Function() preQues,
    required TResult Function() resetSpeech,
    required TResult Function(String? path, String? referenceText)
        sendFileToServer,
  }) {
    return sendFileToServer(path, referenceText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? nextQues,
    TResult? Function()? preQues,
    TResult? Function()? resetSpeech,
    TResult? Function(String? path, String? referenceText)? sendFileToServer,
  }) {
    return sendFileToServer?.call(path, referenceText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? nextQues,
    TResult Function()? preQues,
    TResult Function()? resetSpeech,
    TResult Function(String? path, String? referenceText)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (sendFileToServer != null) {
      return sendFileToServer(path, referenceText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(NextQues value) nextQues,
    required TResult Function(PreQues value) preQues,
    required TResult Function(ResetSpeech value) resetSpeech,
    required TResult Function(SendFileToServer value) sendFileToServer,
  }) {
    return sendFileToServer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(NextQues value)? nextQues,
    TResult? Function(PreQues value)? preQues,
    TResult? Function(ResetSpeech value)? resetSpeech,
    TResult? Function(SendFileToServer value)? sendFileToServer,
  }) {
    return sendFileToServer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(NextQues value)? nextQues,
    TResult Function(PreQues value)? preQues,
    TResult Function(ResetSpeech value)? resetSpeech,
    TResult Function(SendFileToServer value)? sendFileToServer,
    required TResult orElse(),
  }) {
    if (sendFileToServer != null) {
      return sendFileToServer(this);
    }
    return orElse();
  }
}

abstract class SendFileToServer implements SpeechEvent {
  const factory SendFileToServer(
      {final String? path,
      final String? referenceText}) = _$SendFileToServerImpl;

  String? get path;
  String? get referenceText;
  @JsonKey(ignore: true)
  _$$SendFileToServerImplCopyWith<_$SendFileToServerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
